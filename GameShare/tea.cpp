/*$T Common/EncryptAriths/tea.cpp GC 1.140 10/10/07 10:06:30 */


/*$6
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */


#include "stdafx.h"
#include "tea.h"

const uint32 TEA::	DELTA = 0x9e3779b9;

/*
 =======================================================================================================================
 =======================================================================================================================
 */

void TEA::SetUserKey(const byte *userKey)
{
	for(int j = 0; j < 4; j++)
	{
		k[j] = ((uint32) userKey[4 * j] << 24) | ((uint32) userKey[4 * j + 1] << 16) | ((uint32) userKey[4 * j + 2] << 8) | ((uint32) userKey[4 * j + 3]);
	}
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void TEAEncryption::SetUserKey(const byte *key_string)
{
	TEA::SetUserKey(key_string);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void TEAEncryption::ProcessBlock(const byte *in, byte *out) const
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#ifdef IS_LITTLE_ENDIAN
	uint32	y = byteReverse(*(uint32 *) in);
	uint32	z = byteReverse(*(uint32 *) (in + 4));
#else
	uint32	y = *(uint32 *) in;
	uint32	z = *(uint32 *) (in + 4);
#endif
	uint32	sum = 0;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	for(int i = 0; i < ROUNDS; i++)
	{
		sum += DELTA;
		y += (z << 4) + k[0] ^ z + sum ^ (z >> 5) + k[1];
		z += (y << 4) + k[2] ^ y + sum ^ (y >> 5) + k[3];
	}

#ifdef IS_LITTLE_ENDIAN
	* (uint32 *) out = byteReverse(y);
	*(uint32 *) (out + 4) = byteReverse(z);
#else
	* (uint32 *) out = y;
	*(uint32 *) (out + 4) = z;
#endif
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void TEADecryption::SetUserKey(const byte *key_string)
{
	TEA::SetUserKey(key_string);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void TEADecryption::ProcessBlock(const byte *in, byte *out) const
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#ifdef IS_LITTLE_ENDIAN
	uint32	y = byteReverse(*(uint32 *) in);
	uint32	z = byteReverse(*(uint32 *) (in + 4));
#else
	uint32	y = *(uint32 *) in;
	uint32	z = *(uint32 *) (in + 4);
#endif
	uint32	sum = DELTA << LOG_ROUNDS;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	for(int i = 0; i < ROUNDS; i++)
	{
		z -= (y << 4) + k[2] ^ y + sum ^ (y >> 5) + k[3];
		y -= (z << 4) + k[0] ^ z + sum ^ (z >> 5) + k[1];
		sum -= DELTA;
	}

#ifdef IS_LITTLE_ENDIAN
	* (uint32 *) out = byteReverse(y);
	*(uint32 *) (out + 4) = byteReverse(z);
#else
	* (uint32 *) out = y;
	*(uint32 *) (out + 4) = z;
#endif
}
