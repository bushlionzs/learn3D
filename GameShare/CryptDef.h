/*$T Common/EncryptAriths/CryptDef.h GC 1.140 10/10/07 10:06:29 */


/*$6
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */


#ifndef __KLCRYDEF_H__
#define __KLCRYDEF_H__

#include "TypeDefine.h"

typedef unsigned char	byte;
enum CipherDir { ENCRYPTION, DECRYPTION };

template<class T, int bufLen = 1>
struct SecBlock
{

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	SecBlock()
	{
		m_size = bufLen;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~SecBlock()
	{
	}

#if defined(__GNUC__) || defined(__BCPLUSPLUS__)
	operator const void * () const
	{
		return ptr;
	}
	operator void * ()
	{
		return ptr;
	}
#endif
	operator const T * () const
	{
		return ptr;
	}
	operator T * ()
	{
		return ptr;
	}
	uint32	m_size;
	T	ptr[bufLen];
};

#define GETBYTE(x, y)	(uint32) (((x) >> (8 * (y))) & 255)

/*
 =======================================================================================================================
 =======================================================================================================================
 */

template<class T>
inline T rotl(T x, uint32 y)
{
	return((x << y) | (x >> (sizeof(T) * 8 - y)));
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
template<class T>
inline T rotr(T x, uint32 y)
{
	return((x >> y) | (x << (sizeof(T) * 8 - y)));
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
inline uint32 byteReverse(uint32 value)
{
#ifdef FAST_ROTATE
	return(rotr(value, 8U) & 0xff00ff00) | (rotl(value, 8U) & 0x00ff00ff);
#else
	value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
	return rotl(value, 16U);
#endif
}

#define MAX_BLOCK_LEN	64

class	BlockTransformation
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BlockTransformation()
	{
		m_BlockLen = 8;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	virtual~BlockTransformation()
	{
	} virtual void	ProcessBlock(byte *inoutBlock) const = 0;

	virtual void	ProcessBlock(const byte *inBlock, byte *outBlock) const = 0;

	virtual uint32	BlockSize() const = 0;

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	virtual void SetUserKey(const byte *userKey)
	{
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	void ProcessBlockBase(byte *inoutBlock, int inSize)
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		int	count = 0;
		int	tmpSize = inSize;
		byte	buf[MAX_BLOCK_LEN] = { 0 };
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		if(inSize >= MAX_BLOCK_LEN)
		{
			return;
		}

		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		int	fill = inSize % m_BlockLen;
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		if(fill != 0)
		{
			fill = m_BlockLen - fill;
		}

		while(tmpSize > 0)
		{
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			int	offset = count * m_BlockLen;
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			if(offset + m_BlockLen > MAX_BLOCK_LEN)
			{
				return;
			}

			memcpy(buf + offset, inoutBlock + offset, m_BlockLen);
			ProcessBlock(buf + offset);
			tmpSize -= m_BlockLen;
			count++;
		}

		memcpy(inoutBlock, buf, inSize + fill);
	}

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
protected:
	uint32	m_BlockLen;
};
#endif
