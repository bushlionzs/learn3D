/*$T Common/GameUtil.h GC 1.140 10/10/07 10:06:30 */


/*$6
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */


#ifndef __GAMEUTIL_H__
#define __GAMEUTIL_H__

#include "TypeDefine.h"
#include "Define.h"
#include "Struct.h"

#define __PI		3.1415f
#define __HALF_PI	__PI / 2
#define __QUARTER_PI	__PI / 4

#define THREAD_CAPS	(512)

class	ThreadIndent
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	ThreadIndent();
	~	ThreadIndent();

	void	AddThread(TID tid);

	void	SetThreadIndent(TID tid, int32 nValue);
	int32	GetThreadIndent(TID tid);

	TID	m_ThreadID[THREAD_CAPS];
	int32	m_ThreadIndent[THREAD_CAPS];
};

extern ThreadIndent	g_ThreadIndent;

TID			KGetCurrentTID();
TID			GetOrigineThreadID();
uint32			MyGetCurrentPID();

#if defined(__WINDOWS__)
class			FastLock
{
	CRITICAL_SECTION	m_Lock;

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	BOOL	mStatus;

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	FastLock()
	{
		InitializeCriticalSection(&m_Lock);
		mStatus = FALSE;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~FastLock()
	{
		DeleteCriticalSection(&m_Lock);
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void lock()
	{
		EnterCriticalSection(&m_Lock);
		mStatus = TRUE;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void unlock()
	{
		LeaveCriticalSection(&m_Lock);
		mStatus = FALSE;
	};
};
#elif defined(__LINUX__)
class	FastLock
{
	pthread_mutex_t m_Mutex;

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	BOOL	mStatus;

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	FastLock()
	{
		pthread_mutex_init(&m_Mutex, NULL);
		mStatus = FALSE;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~FastLock()
	{
		pthread_mutex_destroy(&m_Mutex);
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Lock()
	{
		pthread_mutex_lock(&m_Mutex);
		mStatus = TRUE;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Unlock()
	{
		pthread_mutex_unlock(&m_Mutex);
		mStatus = FALSE;
	};
};
#endif

class	CTinyTimer
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
private:
	uint32	m_uTickTerm;
	uint32	m_uTickOld;

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	BOOL	m_bOper;

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	CTinyTimer()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL IsSetTimer()
	{
		return m_bOper;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void SetTermTime(uint32 uTerm)
	{
		m_uTickTerm = uTerm;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetTermTime()
	{
		return m_uTickTerm;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetTickOldTime()
	{
		return m_uTickOld;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_uTickTerm = 0;
		m_bOper = FALSE;
		m_uTickOld = 0;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void BeginTimer(uint32 uTerm, uint32 uNow)
	{
		m_bOper = TRUE;
		m_uTickTerm = uTerm;
		m_uTickOld = uNow;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL CountingTimer(uint32 uNow)
	{
		if(!m_bOper) return FALSE;

		/*~~~~~~~~~~~~~~~~*/
		uint32	uNew = uNow;
		uint32	uDelta = 0;
		/*~~~~~~~~~~~~~~~~*/

		if(uNew >= m_uTickOld)
		{
			uDelta = uNew - m_uTickOld;
		}
		else
		{
			if((uNew + 10000) < m_uTickOld)
			{
				uDelta = ((uint32) 0xFFFFFFFF - m_uTickOld) + uNew;
			}
			else
			{
				return FALSE;
			}
		}

		if(uDelta < m_uTickTerm)
		{
			return FALSE;
		}

		m_uTickOld = uNew;

		return TRUE;
	}
};

extern void	SafeSleep(uint32 millionseconds = 0);

extern TID	KGetCurrentTID();
extern TID	GetOrigineThreadID();

struct GLPos;

extern float	KLSqrt(const GLPos *pCur, const GLPos *pTar);

extern float	KLLengthSq(const GLPos *pCur, const GLPos *pTar);

extern float	KLAngle(const GLPos *pCur, const GLPos *pTar);

extern BOOL	KLPosEqual(const GLPos *pA, const GLPos *pB);

extern void	KLRandomPos(GLPos *pPos, const GLPos *pDir, float fRadioMax, float fRadioMin);

extern const char	*KLSocketError();

extern uint32	KLCRC(const char *szString);

/*
 =======================================================================================================================
 =======================================================================================================================
 */

template<class T>
int32 Float2Int(T TValue)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	int32	iValue = (int32) TValue;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	if(TValue - iValue < 0.500000f)
	{
		return iValue;
	}
	else
		return iValue + 1;
}

struct BigInt
{
	int32	m_uLowInt;
	uint32	m_uHighInt;

	BigInt()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_uLowInt = 0;
		m_uHighInt = 0;
	}
};

struct Flag32
{
	uint32	m_wFlags;

	Flag32()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(m_wFlags & (1 << bit)) return TRUE;

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bUpdate)
			m_wFlags |= (1 << bit);
		else
			m_wFlags &= (~(1 << bit));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	static uint32 GetMsgSize()
	{
		return sizeof(uint32);
	}

	void Clear()
	{
		m_wFlags = 0;
	};
};

struct SFlag64
{
	uint32	m_uLowFlags;
	uint32	m_uHighFlags;

	SFlag64()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(bit < 32)
		{
			if(m_uLowFlags & (1 << bit)) return TRUE;
		}
		else
		{
			if(m_uHighFlags & (1 << (bit - 32))) return TRUE;
		}

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bit < 32)
		{
			if(bUpdate)
				m_uLowFlags |= (1 << (int32) bit);
			else
				m_uLowFlags &= (~(1 << (int32) bit));
		}
		else
		{
			if(bUpdate)
				m_uHighFlags |= (1 << (int32) (bit - 32));
			else
				m_uHighFlags &= (~(1 << (int32) (bit - 32)));
		}
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetMsgSize() const
	{
		return sizeof(m_uLowFlags) + sizeof(m_uHighFlags);
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_uLowFlags = 0;
		m_uHighFlags = 0;
	}
};

struct Flag128
{
	uint32	m_uLLowFlags;
	uint32	m_uLHighFlags;
	uint32	m_uHLowFlags;
	uint32	m_uHHighFlags;

	Flag128()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(bit < 32)
		{
			if(m_uLLowFlags & (1 << bit)) return TRUE;
		}
		else if(bit < 64)
		{
			if(m_uLHighFlags & (1 << (bit - 32))) return TRUE;
		}
		else if(bit < 96)
		{
			if(m_uHLowFlags & (1 << (bit - 64))) return TRUE;
		}
		else if(bit < 128)
		{
			if(m_uHHighFlags & (1 << (bit - 96))) return TRUE;
		}

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bit < 32)
		{
			if(bUpdate)
				m_uLLowFlags |= (1 << (int32) bit);
			else
				m_uLLowFlags &= (~(1 << (int32) bit));
		}
		else if(bit < 64)
		{
			if(bUpdate)
				m_uLHighFlags |= (1 << (int32) (bit - 32));
			else
				m_uLHighFlags &= (~(1 << (int32) (bit - 32)));
		}
		else if(bit < 96)
		{
			if(bUpdate)
				m_uHLowFlags |= (1 << (int32) (bit - 64));
			else
				m_uHLowFlags &= (~(1 << (int32) (bit - 64)));
		}
		else if(bit < 128)
		{
			if(bUpdate)
				m_uHHighFlags |= (1 << (int32) (bit - 96));
			else
				m_uHHighFlags &= (~(1 << (int32) (bit - 96)));
		}
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetMsgSize() const
	{
		return sizeof(m_uLLowFlags) + sizeof(m_uLHighFlags) + sizeof(m_uHLowFlags) + sizeof(m_uHHighFlags) ;
	}


	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_uLLowFlags = 0;
		m_uLHighFlags = 0;
		m_uHLowFlags = 0;
		m_uHHighFlags = 0;
	}
};

struct Flag256
{
	uint32	m_u32Flags;
	uint32	m_u64Flags;
	uint32	m_u96Flags;
	uint32	m_u128Flags;
	uint32	m_u160Flags;
	uint32	m_u192Flags;
	uint32	m_u224Flags;
	uint32	m_u256Flags;

	Flag256()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(bit < 32)
		{
			if(m_u32Flags & (1 << bit)) return TRUE;
		}
		else if(bit < 64)
		{
			if(m_u64Flags & (1 << (bit - 32))) return TRUE;
		}
		else if(bit < 96)
		{
			if(m_u96Flags & (1 << (bit - 64))) return TRUE;
		}
		else if(bit < 128)
		{
			if(m_u128Flags & (1 << (bit - 96))) return TRUE;
		}
		else if(bit < 160)
		{
			if(m_u160Flags & (1 << (bit - 128))) return TRUE;
		}
		else if(bit < 192)
		{
			if(m_u192Flags & (1 << (bit - 160))) return TRUE;
		}
		else if(bit < 224)
		{
			if(m_u224Flags & (1 << (bit - 192))) return TRUE;
		}
		else if(bit < 256)
		{
			if(m_u256Flags & (1 << (bit - 224))) return TRUE;
		}

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bit < 32)
		{
			if(bUpdate)
				m_u32Flags |= (1 << (int32) bit);
			else
				m_u32Flags &= (~(1 << (int32) bit));
		}
		else if(bit < 64)
		{
			if(bUpdate)
				m_u64Flags |= (1 << (int32) (bit - 32));
			else
				m_u64Flags &= (~(1 << (int32) (bit - 32)));
		}
		else if(bit < 96)
		{
			if(bUpdate)
				m_u96Flags |= (1 << (int32) (bit - 64));
			else
				m_u96Flags &= (~(1 << (int32) (bit - 64)));
		}
		else if(bit < 128)
		{
			if(bUpdate)
				m_u128Flags |= (1 << (int32) (bit - 96));
			else
				m_u128Flags &= (~(1 << (int32) (bit - 96)));
		}
		else if(bit < 160)
		{
			if(bUpdate)
				m_u160Flags |= (1 << (int32) (bit - 128));
			else
				m_u160Flags &= (~(1 << (int32) (bit - 128)));
		}
		else if(bit < 192)
		{
			if(bUpdate)
				m_u192Flags |= (1 << (int32) (bit - 160));
			else
				m_u192Flags &= (~(1 << (int32) (bit - 160)));
		}
		else if(bit < 224)
		{
			if(bUpdate)
				m_u224Flags |= (1 << (int32) (bit - 192));
			else
				m_u224Flags &= (~(1 << (int32) (bit - 192)));
		}
		else if(bit < 256)
		{
			if(bUpdate)
				m_u256Flags |= (1 << (int32) (bit - 224));
			else
				m_u256Flags &= (~(1 << (int32) (bit - 224)));
		}
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetMsgSize() const
	{
		return sizeof(m_u32Flags) + 
			sizeof(m_u64Flags) + 
			sizeof(m_u96Flags) +
			sizeof(m_u128Flags) +
			sizeof(m_u160Flags) + 
			sizeof(m_u192Flags) +
			sizeof(m_u224Flags) +
			sizeof(m_u256Flags)	;
	}


	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_u32Flags = 0;
		m_u64Flags = 0;
		m_u96Flags = 0;
		m_u128Flags = 0;
		m_u160Flags = 0;
		m_u192Flags = 0;
		m_u224Flags = 0;
		m_u256Flags = 0;
	}
};

#define SM_FREE		(-1)
#define SM_C_READ	0x01
#define SM_C_WRITE	0x02
#define SM_S_READ	0x03
#define SM_S_WRITE	0x04
#define SM_W_READ	0x05
#define SM_W_WRITE	0x06

void	shm_lock(atword *flag, char type);
void	shm_unlock(atword *flag, char type);

#define SHM_LOCK(flag, type)	shm_lock(flag, type);
#define SHM_UNLOCK(flag, type)	shm_unlock(flag, type);

struct SFlag16
{
	uint16	m_wFlags;

	SFlag16()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(m_wFlags & (1 << bit)) return TRUE;

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bUpdate)
			m_wFlags |= (1 << bit);
		else
			m_wFlags &= (~(1 << bit));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetMsgSize() const
	{
		return sizeof(m_wFlags);
	}


	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_wFlags = 0;
	};
};

template<uint32 nSize>
class BitFlags
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	enum { BIT_SIZE = nSize, BYTE_SIZE = 1 +BIT_SIZE / 8, };

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BitFlags(void)
	{
		memset((void *) m_aBitFlags, '\0', sizeof(m_aBitFlags));
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	BitFlags(BitFlags const &rhs)
	{
		memcpy((void *) m_aBitFlags, (void *) (rhs.GetFlags()), sizeof(m_aBitFlags));
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~BitFlags()
	{
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	BitFlags &operator=(BitFlags const &rhs)
	{
		memcpy((void *) m_aBitFlags, (void *) (rhs.GetFlags()), sizeof(m_aBitFlags));
		return *this;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	void MarkAllFlags(void)
	{
		memset((void *) m_aBitFlags, 0xFF, sizeof(m_aBitFlags));
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	void ClearAllFlags(void)
	{
		memset((void *) m_aBitFlags, 0x00, sizeof(m_aBitFlags));
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	BOOL GetFlagByIndex(int32 const nIdx) const
	{
		if(0 > nIdx || BIT_SIZE <= nIdx)
		{
			KCheckEx(FALSE, "[BitFlags::GetFlagByIndex]: Index out of range!");
			return FALSE;
		}

		/*~~~~~~~~~~~~~~~~~~*/
		uint32	nIndex = nIdx;
		/*~~~~~~~~~~~~~~~~~~*/

		return 0 != (m_aBitFlags[nIdx >> 3] & (char) (1 << nIdx % 8));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void ClearFlagByIndex(int32 const nIdx)
	{
		if(0 > nIdx || BIT_SIZE <= nIdx)
		{
			KCheckEx(FALSE, "[BitFlags::ClearFlagByIndex]: Index out of range!");
			return;
		}

		m_aBitFlags[nIdx >> 3] &= ~(0x01 << (nIdx % 8));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void MarkFlagByIndex(int32 const nIdx)
	{
		if(0 > nIdx || BIT_SIZE <= nIdx)
		{
			KCheckEx(FALSE, "[BitFlags::MarkFlagByIndex]: Index out of range!");
			return;
		}

		m_aBitFlags[nIdx >> 3] |= 0x01 << (nIdx % 8);
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetByteSize(void) const
	{
		return BYTE_SIZE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetBitSize(void) const
	{
		return BIT_SIZE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	char const *const GetFlags(void) const
	{
		return m_aBitFlags;
	}

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
protected:
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
private:
	char	m_aBitFlags[BYTE_SIZE];
};
template<typename U, size_t nSizeLimit>
class KLVector
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	enum { SIZE_LIMIT = nSizeLimit, };

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	KLVector(void) :
	m_nCurrentSize(0),
	m_pUnits(NULL)
	{
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~KLVector()
	{
		KSafeDelete_ARRAY(m_pUnits);
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	BOOL Init(size_t nSize)
	{
		if(NULL != m_pUnits)
		{
			KCheckEx(FALSE, "[KLVector::Init]: Init a Used vector!!Check it now.");
			return FALSE;
		}

		if(SIZE_LIMIT < nSize)
		{
			KCheckEx(FALSE, "[KLVector::Init]: Size over flow!! check it now.");
			return FALSE;
		}

		m_pUnits = new U[nSize];
		if(NULL == m_pUnits)
		{
			KCheckEx(FALSE, "[KLVector::Init]: Allocate memory Failed!!Check it now.");
			return FALSE;
		}

		m_nCurrentSize = nSize;
		return TRUE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL Resize(size_t nSize)
	{
		if(SIZE_LIMIT < nSize)
		{
			KCheckEx(FALSE, "[KLVector::Resize]: Size over flow!! check it now.");
			return FALSE;
		}

		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		U	*pNewBlock = new U[nSize];
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		if(NULL == pNewBlock)
		{
			KCheckEx(FALSE, "[KLVector::Resize]: new memory Failed!!Check it now.");
			return FALSE;
		}

		/*~~~~~~~~~~~~~~~*/
		size_t	nCount = 0;
		/*~~~~~~~~~~~~~~~*/

		if(m_nCurrentSize > nSize)
		{
			nCount = nSize;
		}
		else
		{
			nCount = m_nCurrentSize;
		}

		memcpy((void *) pNewBlock, (void const *) m_pUnits, sizeof(U) * nCount);

		KSafeDelete_ARRAY(m_pUnits);

		m_pUnits = pNewBlock;

		m_nCurrentSize = nSize;
		return TRUE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	U const *GetUnitByIndex(size_t nIdx) const
	{
		if(0 <= nIdx && m_nCurrentSize > nIdx)
		{
			return m_pUnits[nIdx];
		}

		return NULL;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL SetUnitByIndex(size_t nIdx, U const &rU)
	{
		if(0 <= nIdx && m_nCurrentSize > nIdx)
		{
			m_pUnits[nIdx] = rU;
			return TRUE;
		}

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	size_t GetCurrentVectorSize(void) const
	{
		return m_nCurrentSize;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetByteSize(void) const
	{
		return sizeof(U) * m_nCurrentSize;
	}

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
protected:
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
private:
	size_t	m_nCurrentSize;
	U	*m_pUnits;
};

#if defined(__WINDOWS__)
#define tvsnprintf	_vsnprintf
#define tstricmp	_stricmp
#define tsnprintf	_snprintf
#elif defined(__LINUX__)
#define tvsnprintf	vsnprintf
#define tstricmp	strcasecmp
#define tsnprintf	snprintf
#endif
char			Data2Ascii(char in);
char			Ascii2Data(char in);

BOOL			CharToString(const char *pIn, uint32 InLength, char *pOut);
BOOL			StringToChar(const char *pIn, uint32 InLength, char *pOut, uint32 OutLimit, uint32 &OutLength);
BOOL			Binary2Str(const char *pIn, uint32 InLength, char *pOut, uint32 OutLimit);
BOOL			Str2Binary(const char *pIn, uint32 InLength, char *pOut, uint32 OutLimit, uint32 &OutLength);
BOOL			CheckStr(const char *pIn, uint32 InLength);
void			ODBCEscapeString(const char *in, uint32 len, char *out);
char			MyToLower(char c);
void			StringLower(char *pStr);

struct SMail;
struct SMailList;
uint32			GetSizeOfMail(const SMail &mail);
uint32			GetSizeOfMailList(const SMailList &maillist);

uint32			GetValueByBit(uint32 nDataValue, int32 nOffset, int32 nSize);
uint32			SetValueByBit(uint32 nDataValue, int32 nOffset, int32 nSize, int32 nValue);

void			tsnprintf_s(char *buffer, size_t count, const char *format, ...);

extern int32		g_CMDArgv;

extern GLTime	g_GLTime;

void			StackDump(const char *type);

BOOL			ReachTime(uint32 desttime, uint32 now);

uint32			CRC(const char *szBuff, int32 nLen);
uint32			CheckSum(const char *szBuff, int32 nLen);
uint64			StrToUINT64(const char *szBuff);
void			PrintU64(uint64 value);
uint32			GetHighSection(uint64 uValue);			
uint32			GetLowSection(uint64 uValue);
uint64			ToUint64(uint32 uHigh, uint32 uLow);


struct SRandomTab
{
	enum { max_record_num = 100000 };
	uint32 m_uCurPoint;
	uint32 m_uRecord[max_record_num];

	SRandomTab()
	{
		srand((unsigned) time(NULL));

		for(int32 i = 0; i < max_record_num; i++) m_uRecord[i] =
			rand()
			* rand();

		m_uCurPoint = 0;
	}
};

struct KL100RandomTab
{
	enum { max_record_num = 100 };

	uint32 m_uRecord[max_record_num];
	uint32 m_uCurPoint;

	KL100RandomTab()
	{
		srand((unsigned) time(NULL));

		for(int32 i = 0; i < max_record_num; i++) m_uRecord[i] = i;

		Reset();
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Reset()
	{
		for(int32 i = 0; i < 100; i++)
		{
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			uint32	uFrom = rand() % max_record_num;
			uint32	uToIndex = rand() % max_record_num;
			uint32	uBuf = m_uRecord[uToIndex];
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			m_uRecord[uToIndex] = m_uRecord[uFrom];
			m_uRecord[uFrom] = uBuf;
		}

		m_uCurPoint = 0;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetRand()
	{
		if(m_uCurPoint >= max_record_num) Reset();

		return m_uRecord[m_uCurPoint++];
	}
};

class	KLRandom
{
	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:
	KLRandom();
	~		KLRandom();

	static void	SetRand(uint32 uKey);

	static uint32	Rand();

#define MAX_KEY_SIZE	100000
	static char	m_pKey[MAX_KEY_SIZE];
	static uint32	m_uKey;
	static FastLock m_Lock;
};
class	RandGenerator
{
	static const uint32	Max32BitLong = 0xFFFFFFFFLU;

	static const uint32	RandomMax = Max32BitLong;

	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	RandGenerator(const uint32 Seed = 0)
	{
		srand(Seed);
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	unsigned long RandUInt(void)
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		uint32	inta = (rand() & 0x00000FFF);
		uint32	intb = ((rand() & 0x00000FFF) << 12);
		uint32	intc = ((rand() & 0x000000FF) << 24);
		uint32	intd = inta + intb + intc;
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		return intd;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	double RandDouble(void)
	{
		return static_cast<double>(RandUInt()) / (static_cast<double>(RandomMax));
	}

	static uint32	GetRand(int32 nStart, int32 nEnd);
};

extern RandGenerator	g_RandGenerator;
class		SeedRand
{
	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:
	SeedRand();
	~		SeedRand();

	void		SetSeed(int32 seed);
	int32		Rand();

	int32		GetSeed();

	static int32	GetRandByKey(int32 seed, int32 key);
	static int32	GetKeyByRand(int32 seed, int32 rand);

	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
private:
	int32	holdrand;
	int32	seed;
};


#if defined(_70_WORLD)
class			MyDecoder
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	MyDecoder()
	{
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~MyDecoder()
	{
	};

	BOOL	DecodeLogin(const char *szVerifyCode, char *szAccount);

	BOOL	DecodeCharMove(const char *szVerifyCode, const GLPos *paTarPos, uint32 offset);

	BOOL	DecodeLockTarget(const char *szVerifyCode, ObjID_t nTargetID, uint32 offset);

	BOOL	DecodeHeartBeat(const char *szVerifyCode, uint32 randNum, uint32 offset);

	BOOL	DecodeMD5PW(const char *szVerifyCode, char *szSource, int32 iSize, uint32 key);
};
#endif
#endif
