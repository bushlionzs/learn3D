/*$T Common/EncryptAriths/rc5.cpp GC 1.140 10/10/07 10:06:30 */


/*$6
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */


#include "stdafx.h"
#include "rc5.h"

#define ROTL(x, y)	(rotl((x), (uint32) (y) % (sizeof(RC5_WORD) * 8)))
#define ROTR(x, y)	(rotr((x), (uint32) (y) % (sizeof(RC5_WORD) * 8)))

/*
 =======================================================================================================================
 =======================================================================================================================
 */

RC5Base::RC5Base(uint32 rounds) :
	r(rounds)
{
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void RC5Base::SetUserKey(const byte *k)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	static const RC5_WORD	MAGIC_P = 0xb7e15163L;
	static const RC5_WORD	MAGIC_Q = 0x9e3779b9L;
	static const int	U = sizeof(RC5_WORD);
	const uint32		c = (KEYLENGTH - 1) / U + 1;
	SecBlock<RC5_WORD, c>	l;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	l[(KEYLENGTH - 1) / U] = 0;
	for(int i = (KEYLENGTH - 1); i >= 0; i--) l[i / U] = (l[i / U] << 8) + k[i];

	sTable[0] = MAGIC_P;
	for(unsigned j = 1; j < sTable.m_size; j++) sTable[j] = sTable[j - 1] + MAGIC_Q;

	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	RC5_WORD	a = 0, b = 0;
	const unsigned	n = 3 * std::max(sTable.m_size, c);
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	for(unsigned h = 0; h < n; h++)
	{
		a = sTable[h % sTable.m_size] = ROTL((sTable[h % sTable.m_size] + a + b), 3);
		b = l[h % c] = ROTL((l[h % c] + a + b), (a + b));
	}
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
static inline void GETBLOCK(const byte *block, uint32 &left, uint32 &right)
{
#ifdef IS_LITTLE_ENDIAN
	left = *(uint32 *) block;
	right = *(uint32 *) (block + 4);
#else
	left = byteReverse(*(uint32 *) block);
	right = byteReverse(*(uint32 *) (block + 4));
#endif
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
static inline void PUTBLOCK(byte *block, uint32 left, uint32 right)
{
#ifdef IS_LITTLE_ENDIAN
	* (uint32 *) block = left;
	*(uint32 *) (block + 4) = right;
#else
	* (uint32 *) block = byteReverse(left);
	*(uint32 *) (block + 4) = byteReverse(right);
#endif
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void RC5Encryption::SetUserKey(const byte *key)
{
	RC5Base::SetUserKey(key);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void RC5Encryption::ProcessBlock(const byte *in, byte *out) const
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	const RC5_WORD	*sptr = sTable;
	RC5_WORD	a, b;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	GETBLOCK(in, a, b);
	a += sptr[0];
	b += sptr[1];
	sptr += 2;

	for(unsigned i = 0; i < r; i++)
	{
		a = ROTL(a ^ b, b) + sptr[2 * i + 0];
		b = ROTL(a ^ b, a) + sptr[2 * i + 1];
	}

	PUTBLOCK(out, a, b);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void RC5Decryption::SetUserKey(const byte *key)
{
	RC5Base::SetUserKey(key);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void RC5Decryption::ProcessBlock(const byte *in, byte *out) const
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	const RC5_WORD	*sptr = sTable + sTable.m_size;
	RC5_WORD	a, b;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	GETBLOCK(in, a, b);

	for(unsigned i = 0; i < r; i++)
	{
		sptr -= 2;
		b = ROTR(b - sptr[1], a) ^ a;
		a = ROTR(a - sptr[0], b) ^ b;
	}

	b -= sTable[1];
	a -= sTable[0];

	PUTBLOCK(out, a, b);
}
