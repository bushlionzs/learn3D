/*$T Common/EncryptAriths/Idea.cpp GC 1.140 10/10/07 10:06:29 */


/*$6
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */


#include "stdafx.h"
#include "Idea.h"

#define low16(x)	((x) & 0xffff)
#define high16(x)	((x) >> 16)
#define DirectMUL(a, b) \
	{ \
		uint32	p = (uint32) low16(a) * b; \
		if(p) \
		{ \
			p = low16(p) - high16(p); \
			a = (uint32) p - (uint32) high16(p); \
		} \
		else \
			a = 1 - a - b; \
	}

/*
 =======================================================================================================================
 =======================================================================================================================
 */

void IDEA::SetUserKey(const byte *userKey, CipherDir direction)
{
	EnKey(userKey);

	if(direction == DECRYPTION) DeKey();
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void IDEA::EnKey(const byte *userKey)
{
	/*~~~~~~~~~~~~~*/
	int	i, j;
	uint32	*Z = key;
	/*~~~~~~~~~~~~~*/

	for(j = 0; j < 8; j++) Z[j] = (userKey[2 * j] << 8) + userKey[2 * j + 1];
	for(i = 0; j < IDEA_KEYLEN; j++)
	{
		i++;
		Z[i + 7] = low16((Z[i & 7] << 9) | (Z[i + 1 & 7] >> 7));
		Z += i & 8;
		i &= 7;
	}
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
static uint32 inv(uint32 x)
{
	/*~~~~~~~~~~*/
	uint32	y = x;
	/*~~~~~~~~~~*/

	for(uint32 i = 0; i < 15; i++)
	{
		DirectMUL(y, low16(y));
		DirectMUL(y, x);
	}

	return low16(y);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void IDEA::DeKey()
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	uint32				*Z = key;
	int				j;
	uint32				t1, t2, t3;
	SecBlock<uint32, IDEA_KEYLEN>	tempKey;
	uint32				*p = tempKey + IDEA_KEYLEN;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	t1 = inv(*Z++);
	t2 = low16(0 -*Z++);
	t3 = low16(0 -*Z++);
	*--p = inv(*Z++);
	*--p = t3;
	*--p = t2;
	*--p = t1;
	for(j = 1; j < ROUNDS; j++)
	{
		t1 = *Z++;
		*--p = *Z++;
		*--p = t1;
		t1 = inv(*Z++);
		t2 = low16(0 -*Z++);
		t3 = low16(0 -*Z++);
		*--p = inv(*Z++);
		*--p = t2;
		*--p = t3;
		*--p = t1;
	}

	t1 = *Z++;
	*--p = *Z++;
	*--p = t1;
	t1 = inv(*Z++);
	t2 = low16(0 -*Z++);
	t3 = low16(0 -*Z++);
	*--p = inv(*Z++);
	*--p = t3;
	*--p = t2;
	*--p = t1;

	memcpy(key, tempKey, IDEA_KEYLEN * sizeof(uint32));
}

#define MUL(a, b)	DirectMUL(a, b)

/*
 =======================================================================================================================
 =======================================================================================================================
 */

void IDEA::ProcessBlock(const byte *in, byte *out) const
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	uint32	x1, x2, x3, x4, t1, t2;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef IS_LITTLE_ENDIAN
	x1 = byteReverse(((uint16 *) in)[0]);
	x2 = byteReverse(((uint16 *) in)[1]);
	x3 = byteReverse(((uint16 *) in)[2]);
	x4 = byteReverse(((uint16 *) in)[3]);
#else
	x1 = ((uint16 *) in)[0];
	x2 = ((uint16 *) in)[1];
	x3 = ((uint16 *) in)[2];
	x4 = ((uint16 *) in)[3];
#endif

	/*~~~~~~~~~~~~~~~~~~~~~~~*/
	const uint32	*Z = key;
	int		r = ROUNDS;
	/*~~~~~~~~~~~~~~~~~~~~~~~*/

	do
	{
		MUL(x1, Z[0]);
		x2 += Z[1];
		x3 += Z[2];
		MUL(x4, Z[3]);
		t2 = x1 ^ x3;
		MUL(t2, Z[4]);
		t1 = t2 + (x2 ^ x4);
		MUL(t1, Z[5]);
		Z += 6;
		t2 += t1;
		x1 ^= t1;
		x4 ^= t2;
		t2 ^= x2;
		x2 = x3 ^ t1;
		x3 = t2;
	} while(--r);
	MUL(x1, Z[0]);
	x3 += Z[1];
	x2 += Z[2];
	MUL(x4, Z[3]);

#ifdef IS_LITTLE_ENDIAN
	((uint16 *) out)[0] = byteReverse(uint16(x1));
	((uint16 *) out)[1] = byteReverse(uint16(x3));
	((uint16 *) out)[2] = byteReverse(uint16(x2));
	((uint16 *) out)[3] = byteReverse(uint16(x4));
#else
	((uint16 *) out)[0] = x1;
	((uint16 *) out)[1] = x3;
	((uint16 *) out)[2] = x2;
	((uint16 *) out)[3] = x4;
#endif
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void IDEAEncryption::SetUserKey(const byte *userKey)
{
	IDEA::SetUserKey(userKey, ENCRYPTION);
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void IDEADecryption::SetUserKey(const byte *userKey)
{
	IDEA::SetUserKey(userKey, DECRYPTION);
}
