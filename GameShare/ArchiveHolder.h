
#ifndef __ARCHIVEHOLDER_H__
#define __ARCHIVEHOLDER_H__

////////////////////////////////////////////////////////////////////////////////
// API Module
////////////////////////////////////////////////////////////////////////////////
#include "TypeDefine.h"

#ifdef __WINDOWS__
#define INVALID_SM_HANDLE	((void *) 0)
#elif __LINUX__
#define INVALID_SM_HANDLE	- 1
#endif
class	ArchiveNode
{
	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:
	static MKHandle CreateMemKeeper(MK_VALUE key, uint32 Size);
	static MKHandle OpenMenKeeper(MK_VALUE key, uint32 Size);
	static char	*ViewMemKeeper(MKHandle handle);
	static void	UnViewMemKeeper(char *MemoryPtr);
	static void	TerminateMemKeeper(MKHandle handle);
};

////////////////////////////////////////////////////////////////////////////////
// Unit Module
////////////////////////////////////////////////////////////////////////////////
#include "StructDB.h"

#define SHMEM_LOG_PATH	"./Log/DBShare"

class	ArchiveNodeWrapper
{
	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	ArchiveNodeWrapper()
	{
		m_pDataPtr = 0;
		m_hold = 0;
		m_Size = 0;
		m_pHeader = 0;
		memset(m_LogPath, 0, sizeof(m_LogPath));
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	~ArchiveNodeWrapper()
	{
	};

	/*
	===============================================================================================================
	===============================================================================================================
	*/

	BOOL InitLog(const char *LogPtr)
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		__GUARD__	KCheck(LogPtr);
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		strncpy(m_LogPath, LogPtr, 255 - 1);

		return TRUE;
		__UNGUARD__ return FALSE;
	}

	BOOL	Create(MK_VALUE key, uint32 Size);
	void	Destory();
	BOOL	ViewMap(MK_VALUE, uint32 Size);

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	char *GetDataPtr()
	{
		return m_pDataPtr;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	char *GetTypePtr(uint32 tSize, uint32 tIndex)
	{
		KCheck(tSize > 0);
		KCheck(tSize * tIndex < m_Size);
		if(tSize <= 0 || tIndex >= m_Size) return NULL;
		return m_pDataPtr + tSize * tIndex;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetSize()
	{
		return m_Size;
	}

	uint32	GetUpdateTime();
	void	SetUpdateTime(uint32 ver);
	int32	m_CmdArg;

	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
private:
	uint32		m_Size;
	char		*m_pDataPtr;
	char		*m_pHeader;
	MKHandle	m_hold;
	char		m_LogPath[255];
};

////////////////////////////////////////////////////////////////////////////////
// Manager Module
////////////////////////////////////////////////////////////////////////////////
#define MAX_MANAGER_MK 5000
#define MAX_SM_OBJ_NUM	20

enum MKPOOL_TYPE { SMPT_SHAREMEM, SMPT_SERVER, SMPT_WORLD };

template<typename T>
class ArchiveNodePool
{
	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	ArchiveNodePool()
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		__GUARD__	m_pInstancePtr = NULL;
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		m_hObj = NULL;
		m_nMaxSize = -1;
		m_nPosition = -1;
		__UNGUARD__
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	~ArchiveNodePool()
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		__GUARD__	KCheck(m_pInstancePtr);
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		m_pInstancePtr->Destory();
		KSafeDelete(m_pInstancePtr);
		KSafeDelete_ARRAY(m_hObj);

		__UNGUARD__
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	BOOL Init(uint32 nMaxCount, MK_VALUE key, MKPOOL_TYPE SMPT, const char *LogPath)
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		__GUARD__	m_pInstancePtr = new ArchiveNodeWrapper();
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		KCheck(m_pInstancePtr);

		if(!m_pInstancePtr) return FALSE;

		m_pInstancePtr->InitLog(LogPath);
		m_pInstancePtr->m_CmdArg = g_CMDArgv;

		/*~~~~~~~~*/
		BOOL	ret;
		/*~~~~~~~~*/

		ret = m_pInstancePtr->ViewMap(key, sizeof(T) * nMaxCount + sizeof(SMHead));

		if(SMPT == SMPT_SHAREMEM)
		{
			if(!ret)
			{
				ret = m_pInstancePtr->Create(key, sizeof(T) * nMaxCount + sizeof(SMHead));
			}
		}
		else
		{
			if(!ret)
			{
				return FALSE;
			}
		}

		if(!ret)
		{
			if(m_pInstancePtr->m_CmdArg == CMD_MODE_CLEARALL)
			{
				return TRUE;
			}

			KCheck(ret);
			return ret;
		}

		m_nMaxSize = nMaxCount;
		m_nPosition = 0;
		m_hObj = new T *[m_nMaxSize];

		/*~~~~~~*/
		int32	i;
		/*~~~~~~*/

		for(i = 0; i < m_nMaxSize; i++)
		{
			m_hObj[i] = reinterpret_cast < T * > (m_pInstancePtr->GetTypePtr(sizeof(T), i));
			if(m_hObj[i] == NULL)
			{
				KCheck(m_hObj[i] != NULL);
				return FALSE;
			}
		}

		m_key = key;

		return TRUE;
		__UNGUARD__ return FALSE;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	BOOL Finalize()
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		__GUARD__	KCheck(m_pInstancePtr);
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		m_pInstancePtr->Destory();
		return TRUE;

		__UNGUARD__ return FALSE;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	T *NewObj(void)
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		__GUARD__	KCheck(m_nPosition < m_nMaxSize);
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		if(m_nPosition >= m_nMaxSize)
		{
			return NULL;
		}

		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		T	*pObj = m_hObj[m_nPosition];
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		pObj->SetPoolID((uint32) m_nPosition);
		m_nPosition++;
		return pObj;
		__UNGUARD__ return NULL;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void DeleteObj(T *pObj)
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		__GUARD__	KCheck(pObj != NULL);
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		if(pObj == NULL)
		{
			return;
		}

		KCheck(m_nPosition > 0);
		if(m_nPosition <= 0)
		{
			return;
		}

		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		uint32 uDelIndex = pObj->GetPoolID();
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		KCheck(uDelIndex < (uint32) m_nPosition);
		if(uDelIndex >= (uint32) m_nPosition)
		{
			return;
		}

		m_nPosition--;

		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		T	*pDelObj = m_hObj[uDelIndex];
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		m_hObj[uDelIndex] = m_hObj[m_nPosition];
		m_hObj[m_nPosition] = pDelObj;

		m_hObj[uDelIndex]->SetPoolID(uDelIndex);
		m_hObj[m_nPosition]->SetPoolID(INVALID_ID);
		__UNGUARD__
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	T *GetPoolObj(int32 iIndex)
	{
		KCheck(iIndex < m_nMaxSize);
		return m_hObj[iIndex];
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	int32 GetPoolMaxSize()
	{
		return m_nMaxSize;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	int32 GetPoolSize()
	{
		return m_nPosition;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	MK_VALUE GetKey()
	{
		return m_key;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	BOOL DumpToFile(char *FilePath)
	{
		if(!m_pInstancePtr)
		{
			KCheck(m_pInstancePtr);
			return FALSE;
		}

		return TRUE;

		/*
		* return m_pInstancePtr->DumpToFile(FilePath);
		*/
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	BOOL MergeFromFile(char *FilePath)
	{
		if(!m_pInstancePtr)
		{
			KCheck(m_pInstancePtr);
			return FALSE;
		}

		return TRUE;

		/*
		* return m_pInstancePtr->MergeFromFile(FilePath);
		*/
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetHeadVer()
	{
		KCheck(m_pInstancePtr);
		return m_pInstancePtr->GetUpdateTime();
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void SetHeadVer(uint32 ver)
	{
		KCheck(m_pInstancePtr);
		return m_pInstancePtr->SetUpdateTime(ver);
	}

	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
private:
	T	**m_hObj;
	int32 m_nMaxSize;
	int32 m_nPosition;
	ArchiveNodeWrapper *m_pInstancePtr;
	MK_VALUE m_key;
};

template<typename T>
class MKManager
{
	T	*m_pMK[MAX_MANAGER_MK];

	int32 m_nCount;

	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	MKManager() :
	  m_nCount(0)
	  {
		  memset(m_pMK, 0, sizeof(T *) * MAX_MANAGER_MK);
	  }

	  /*
	  ===============================================================================================================
	  ===============================================================================================================
	  */
	  ~MKManager()
	  {
	  }

	  /*
	  ===============================================================================================================
	  ===============================================================================================================
	  */
	  void Init()
	  {
		  /*~~~~~~~~~~~~~~~~~~~*/
		  __GUARD__ m_nCount = 0;
		  /*~~~~~~~~~~~~~~~~~~~*/

		  return TRUE;
		  __UNGUARD__ return FALSE;
	  }

	  BOOL	HeartBeat(uint32 uTime = 0);

	  /*
	  ===============================================================================================================
	  ===============================================================================================================
	  */

	  BOOL AddMK(T *pMK)
	  {
		  /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		  __GUARD__	KCheck(m_nCount < MAX_MANAGER_MK);
		  /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		  if(m_nCount >= MAX_MANAGER_MK) return FALSE;

		  m_pMK[m_nCount] = pMK;
		  m_pMK->SetMKID(m_nCount);
		  m_nCount++;
		  return TRUE;
		  __UNGUARD__ return FALSE;
	  }

	  /*
	  ===============================================================================================================
	  ===============================================================================================================
	  */
	  BOOL DelMK(T *pMK)
	  {
		  /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		  __GUARD__ uint32 uID = pMK->GetMKID();
		  /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		  KCheck(uID < (uint32) m_nCount);
		  if(uID >= (uint32) m_nCount) return FALSE;

		  KCheck(m_pMK[uID] == pMK);
		  if(m_pMK[uID] != pMK) return FALSE;

		  m_pMK[uID] = m_pMK[m_nCount - 1];
		  m_pMK[uID]->SetMKID(uID);
		  pMK->SetMKID(INVALID_ID);
		  m_nCount--;

		  return TRUE;
		  __UNGUARD__ return FALSE;
	  }

	  /*
	  ===============================================================================================================
	  ===============================================================================================================
	  */
	  T *GetMK(MKID_t MKId)
	  {
		  KCheck(MKId < m_nCount);
		  if(MKId >= m_nCount) return NULL;
		  return m_pMK[MKId];
	  }
};

#endif
