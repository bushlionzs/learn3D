/*$T MapServer/Server/Obj/ItemBox.cpp GC 1.140 10/10/07 10:07:31 */


/*$6
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */


#include "stdafx.h"
#include "ItemBox.h"
#include "map/game_map.h"
#include "BaseTool.h"
#include "server_settting.h"
#include "TabDefine.h"
#include "Item_Base.h"
#include "Item_Interface.h"
#include "net/messages/SCNewItemBox.h"
#include "gameobject/Player.h"


/*
 =======================================================================================================================
 =======================================================================================================================
 */

ItemBox::ItemBox()
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__ Item		itemIterator;
	SItemContainerInit	containInit;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	containInit.m_nContainerSize = MAX_BOXITEM_NUMBER;
	m_Container.Init(&containInit);

	for(int i = 0; i < MAX_BOXITEM_NUMBER; i++)
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		CItemInit	itemInit(&m_ItemList[i]);
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		m_Container.GetItem(i)->Init(&itemInit);
	}

	__UNGUARD__
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
ItemBox::~ItemBox()
{
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
BOOL ItemBox::Init(const _INIT_OBJECT *pInit)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	Clear();
	BOOL		bResult = Object::Init(pInit);
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	if(!bResult) return FALSE;

	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	_INIT_ITEMBOX_OBJECT	*pItemBoxInit = (_INIT_ITEMBOX_OBJECT *) pInit;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	if(pItemBoxInit == NULL) return FALSE;

	m_CreateTime = pItemBoxInit->m_uCreateTime;
	m_RecycleTime = pItemBoxInit->m_uRecycleTime;
	m_ItemBoxType = pItemBoxInit->m_ItemBoxType;
	if(pItemBoxInit->m_bRecycle)
	{
		m_RecycleTimer.BeginTimer(m_RecycleTime, m_CreateTime);
	}
	else
	{
		m_RecycleTimer.Clear();
	}

	__UNGUARD__ return TRUE;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
bool ItemBox::HeartBeat(uint32 uTime)
{
	 return FALSE;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
NetPacket* ItemBox::CreateNewObjMsg(void)
{
	SCNewItemBox* packet = new SCNewItemBox;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	packet->setObjType(GetType());
	packet->setObjectId(GetID());
	packet->setOwner(GetOwner());
	packet->setWorldPos((GetGLPos()));
	packet->setDropMonsterId(GetDropMonsterID());
	return packet;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::DestroyNewObjMsg(NetPacket*pPacket)
{
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
BOOL ItemBox::CanPickBox(GUID_t PickerID, ObjID_t HumanID)
{
	if (m_OwnerId == INVALID_ID) return TRUE;

	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	Player* pPlayer = GetMap()->getPlayer(HumanID);
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	KCheck(pPlayer);

	if (GetType() == ITYPE_DROPBOX)
	{
		return PickerID == m_OwnerId;
	}
	else
	{
		if (PickerID == m_OwnerId)
			return TRUE;
		else
		{
			return GET_TIME().TickCount() > (uint32)m_FinalPickTime;
		}
	}
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
BOOL ItemBox::IsCanViewMe(const Object *pObj)
{
	if (!pObj) 
		return FALSE;

	if (GetType() == ITYPE_DROPBOX)
	{
		if (pObj->GetObjType() == OBJECT_CLASS_PLAYER)
		{
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			Player* pPlayer = (Player*)pObj;
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			if (!pPlayer) return FALSE;

			return m_OwnerId == pPlayer->GetGUID() || m_OwnerId == INVALID_ID;
		}
	}

	return TRUE;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::EnablePickOwnerTime()
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	m_FinalPickTime = GET_TIME().TickCount() + m_PickOwnerTime;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	__UNGUARD__
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::SetPickOwnerTime(uint32 uPickTime)
{
	m_PickOwnerTime = uPickTime;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::Set_Property_MaxGrowTime(uint32 uGrowTime)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	m_MaxGrowTime = uGrowTime;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	m_LifeTimer.BeginTimer(m_MaxGrowTime, GET_TIME().TickCount());

	__UNGUARD__
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::Recycle()
{
	
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::Clear()
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	m_ItemCount = 0;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	m_CreateTime = 0;
	m_RecycleTime = 0;
	m_MaxGrowTime = 0;
	m_ItemBoxType = -1;
	m_RecycleTimes = 0;
	m_OpenFlag = FALSE;

	memset(m_ItemList, 0, sizeof(SItem) * MAX_BOXITEM_NUMBER);
	for(int i = 0; i < MAX_BOXITEM_NUMBER; i++)
	{
		m_IPCList[i].Clear();
	}

	m_LifeTimer.Clear();

	m_PickOwnerTime = 0;

	m_FinalPickTime = 0;
	m_OwnerId = INVALID_ID;
	m_OwnerTeam = INVALID_ID;
	m_MonsterID = INVALID_ID;

	__UNGUARD__
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
SItem *ItemBox::GetItem(uchar itemIndex)
{
	__GUARD__ return &m_ItemList[itemIndex];

	__UNGUARD__ return NULL;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::EraseItem(uchar itemIndex)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	KCheck(itemIndex <= m_ItemCount);
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	memcpy(m_ItemList + itemIndex, m_ItemList + m_ItemCount - 1, sizeof(SItem));
	memset(m_ItemList + m_ItemCount - 1, 0, sizeof(SItem));
	m_ItemCount--;

	__UNGUARD__
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::SetItemCount(uchar itemCount)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	KCheck(itemCount <= MAX_BOXITEM_NUMBER);
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	m_ItemCount = itemCount;

	__UNGUARD__
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
uchar ItemBox::GetItemCount()
{
	return m_ItemCount;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
void ItemBox::SetItemBoxData(SItem *pData)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	KCheck(m_ItemCount > 0 && m_ItemCount <= MAX_BOXITEM_NUMBER);
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	memcpy(m_ItemList, pData, sizeof(SItem) * m_ItemCount);
	__UNGUARD__
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
const SItem *ItemBox::GetItemBoxData()
{
	__GUARD__ return m_ItemList;
	__UNGUARD__
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
int32 ItemBox::AddItem(SItemBoxContaner *pContain, int32 nDestIndex)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	KCheck(pContain);
	BOOL		bNewPos = FALSE;
	int32		nIndex = sItemInterface.CopyItemFromItemBox(pContain, nDestIndex, bNewPos, GetContainer());
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	if(bNewPos) m_ItemCount++;

	return nIndex;

	__UNGUARD__ return INVALID_INDEX;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
BOOL ItemBox::CreateItem(ItemLogRecordInfo *pLogParam, uint32 uItemType, uint32 uQuality)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	__GUARD__	KCheck(pLogParam);
	BOOL		bNewPos = FALSE;
	uint32		uContainerPos;
	BOOL		bCreate = sItemInterface.CreateItemToContainer
		(
			pLogParam,
			uItemType,
			GetContainer(),
			bNewPos,
			uContainerPos
		);
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	if(bNewPos)
	{
		m_ItemCount++;
	}

	return bCreate;

	__UNGUARD__ return FALSE;
}

/*
 =======================================================================================================================
 =======================================================================================================================
 */
ScriptID_t ItemBox::GetScriptID() const
{
	__GUARD__ if(m_ItemBoxType == ITYPE_DROPBOX)
	{
		return INVALID_ID;
	}

	

	return INVALID_ID;

	__UNGUARD__ return INVALID_ID;
}
